#' @title Fit a multinomial change point Time Series model
#'
#' @description Fit a set of multinomial regression models to a time series of
#'   of data divided into multiple chunks based on change points. 
#'
#' @param data Class \code{data.frame} object including [1] the time variable
#'   (indicated in \code{control}), [2] the predictor variables (required by
#'   \code{formula}) and [3], the multinomial response variable (indicated
#'   in \code{formula}). Note that the response variables should be formatted
#'   as \code{<name>.1}, \code{<name>.2}, etc. (where \code{<name>} is the
#'   actual name of the response variable, such as \code{gamma} for a standard
#'   TS analysis on LDA output. 
#'
#' @param formula \code{formula} describing the continuous change. Any 
#'   predictor variable included must also be a column in the
#'   \code{data}. Any (multinomial) response variable must also be a set of
#'   columns in \code{data}. 
#'
#' @param changepoints Numeric vector indicating locations of the change 
#'   points.
#'
#' @param weights Optional class \code{numeric} vector of weights for each 
#'   document. Corresponds to the vector \strong{\eqn{v}} in the math 
#'   description.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}.
#'
#' @return Object of class \code{multinom_TS_fit}, which is a list of [1]
#'   chunk-level model fits and [2] the total log likelihood combined across 
#'   all chunks.
#'
#' @export 
#'
multinom_TS <- function(data, formula, changepoints = NULL, 
                        weights = NULL, control = TS_controls_list()){

  if (!check_changepoints(data, changepoints, control$timename)){
    return(list("chunk models" = NA, "logLik" = -Inf))
  }

  TS_chunk_memo <- memoise_fun(multinom_TS_chunk, control$memoise)

  chunks <- prep_chunks(data, changepoints, control$timename)
  nchunks <- nrow(chunks)
  fits <- vector("list", length = nchunks)
  for (i in 1:nchunks){
    fits[[i]] <- TS_chunk_memo(data, formula, chunks[i, ], weights)
  }
  package_chunk_fits(chunks, fits)
}


#' @title Package the output of the chunk-level multinomial models into a
#'    
#' @description Takes the list of fitted chunk-level models returned from
#'   \code{TS_chunk_memo} (the memoised version of 
#'   \code{\link{multinom_TS_chunk}} and packages it as a 
#'   \code{multinom_TS_fit} object. This involves naming the model fits based 
#'   on the chunk time windows, combining the log likelihood values across the 
#'   chunks, and setting the class of the output object. 
#'
#' @param chunks Data frame of \code{start} and \code{end} times for each 
#'   chunk (row).
#'
#' @param fits List of chunk-level fits returned by \code{TS_chunk_memo},
#'   (the memoised version of \code{\link{multinom_TS_chunk}}  
#'
#' @return Object of class \code{multinom_TS_fit}, which is a list of [1]
#'   chunk-level model fits and [2] the total log likelihood combined across 
#'   all chunks.
#'
#' @export 
#'
package_chunk_fits <- function(chunks, fits){
  nchunks <- nrow(chunks)
  chunk_times <- paste0("(", chunks[ , "start"], " - ", chunks[ , "end"], ")")
  names(fits) <- paste("chunk", 1:nchunks, chunk_times, "model")
  ll <- sum(sapply(fits, logLik))
  out <- list("chunk models" = fits, "logLik" = ll)
  attr(out, "class") <- c("multinom_TS_fit", "list")
  out
}

#' @title Prepare the time chunk table for a multinomial change point 
#'   Time Series model
#'
#' @description Creates the table containing the start and end times for each
#'   chunk within a time series, based on the changepoints (used to break up
#'   the time series) and the range of the time series. If there are no 
#'   changepoints (i.e. \code{changepoints} is \code{NULL}, there is still a
#'   single chunk defined by the start and end of the time series.
#'
#' @param data Class \code{data.frame} object including the predictor and 
#'   response variables, but specifically here containing the column indicated
#'   by the \code{timename} input. 
#'
#' @param changepoints Numeric vector indicating locations of the change 
#'   points.
#'
#' @param timename The name of the column containing the time variable used 
#'   to chunk out the time series. Generally contained in the \code{control}
#'   (class \code{TS_controls}) list.
#'
#' @return Data frame of \code{start} and \code{end} times for each chunk 
#'   (row).
#'
#' @export 
#'
prep_chunks <- function(data, changepoints = NULL, 
                        timename = TS_controls_list()$timename){
  start <- c(min(data[ , timename]), changepoints + 1)   
  end <- c(changepoints, max(data[ , timename])) 
  data.frame(start, end)
}

#' @title Verify the change points of a multinomial time series model
#'
#' @description Check to verify that a time series can be broken into a set 
#'   of chunks based on input changepoints. 
#'
#' @param data Class \code{data.frame} object including the predictor and 
#'   response variables.
#'
#' @param changepoints Numeric vector indicating locations of the change 
#'   points.
#'
#' @param timename Character name of the column in the 
#'   \code{document_covariate_table} that contains the time index to use
#'   for assignment of the changepoints (corresponding to the vector 
#'   \strong{\eqn{t}} in the mathematical description of the model). 
#'
#' @return Logical indicator of the check passing \code{TRUE} or failing
#'   \code{FALSE}.
#'
#' @export 
#'
check_changepoints <- function(data, changepoints = NULL, 
                               timename = TS_controls_list()$timename){

  if (is.null(changepoints)){
    return(TRUE)
  }

  first_time <- min(data[ , timename])
  last_time <- max(data[ , timename])
  time_check <- any(changepoints <= first_time | changepoints >= last_time)
  sort_check <- is.unsorted(changepoints, strictly = TRUE)

  !(time_check | sort_check)
}

#' @title Fit a multinomial Time Series model chunk
#'
#' @description Fit a multinomial regression model to a defined chunk of time
#'   \code{[chunk$start, chunk$_time]} within a time series. The fit is 
#'   conducted via \code{\link[nnet]{multinom}}.
#'
#' @param data Class \code{data.frame} object including the predictor and 
#'   response variables.
#'
#' @param formula Formula as a class \code{formula} or class \code{character} 
#'   object describing the chunk.
#'
#' @param chunk Length-2 vector of times: [1] \code{start}, the start time 
#'   for the chunk and [2] \code{end}, the end time for the chunk.
#'
#' @param weights Optional class \code{numeric} vector of weights for each 
#'   document. Corresponds to the vector \strong{\eqn{v}} in the math 
#'   description.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model, generated by \code{\link{TS_controls_list}}.
#' 
#' @return Fitted model object for the chunk, of classes \code{multinom} and
#'   \code{nnet}.
#' 
#' @references 
#'   Ripley, B. D. 1996. Pattern Recognition and Neural Networks. Cambridge.
#'
#'   Venables, W. N. and B. D. Ripley. 2002. Modern Applied Statistics with S.
#'   Fourth edition. Springer. 
#'
#' @export 
#'
multinom_TS_chunk <- function(data, formula, chunk, weights = NULL,
                              control = TS_controls_list()){

  formula <- as.formula(format(formula))
  time_obs <- data[ , control$timename] 
  chunk_start <- as.numeric(chunk["start"])
  chunk_end <- as.numeric(chunk["end"])
  in_chunk <- time_obs >= chunk_start & time_obs <= chunk_end
  fit <- multinom(formula, data, weights, subset = in_chunk, trace = FALSE) 
}
