#' @title Conduct a set of Time Series analyses on a set of LDA models
#'
#' @description This is a wrapper function that expands the main Time Series
#'   analyses function (\code{\link{TS}}) across the LDA models and the Time
#'   Series models, with respect to both continuous time formulas and the 
#'   number of discrete changepoints. This function allows direct passage of
#'   the control parameters for the parallel tempering MCMC through to the 
#'   main Time Series function, \code{\link{TS}}, via the 
#'   \code{ptMCMC_controls} argument.
#'
#' @param LDA_models List of LDA models (class \code{LDA_set}) or a singular
#'   LDA model (class \code{LDA}).
#'
#' @param document_covariate_table Document covariate table (rows:
#'   documents (\code{M}), columns: time index and covariate options). 
#'   Every model needs a covariate to describe the time value for each
#'   document (in whatever relevant units), whose name in the table is input
#'   via \code{timename}, that dictates the application of the changepoints. 
#'   In addition, the table needs to include as columns all covariates named 
#'   within the specific models described via the argument \code{formula} 
#'   (if desired). Must be a conformable to a data table. 
#'
#' @param formulas Vector of \code{formula}(s) for the continuous change. Any 
#'   predictor variable included in a formula must also be a column in the
#'   \code{document_covariate_table}. Each element (formula) in the vector
#'   is evaluated for each number of change points and each LDA model.
#'
#' @param nchangepoints Vector of integers corresponding to the number of 
#'   change points to include in the model. 0 is a valid input (corresponding
#'   to no change points, so a singular time series model), and the current 
#'   implementation can reasonably include up to 6 change points. Each element 
#'   (number of change points) in the vector is used to dictate the
#'   segementation of the data  for each continuous model and each LDA model.
#'
#' @param weights Optional class \code{numeric} vector of weights for each 
#'   document. Corresponds to the vector \strong{\eqn{v}} in the math 
#'   description.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}.
#'
#' @return Class \code{TS_on_LDA} list of results from \code{\link{TS}} 
#'   applied for each model on each LDA model input.
#'
#' @export
#'
TS_on_LDA <- function(LDA_models, document_covariate_table, formulas = ~ 1, 
                      nchangepoints = 0, weights = NULL, 
                      control = TS_controls_list()){
  check_TS_on_LDA(match.call())
  mods <- expand_TS(LDA_models, formulas, nchangepoints)
  nmods <- nrow(mods)
  TSmods <- vector("list", nmods)

  for(i in 1:nmods){
    print_model_run_message(mods, i, LDA_models, control)
    formula_i <- mods$formula[[i]]
    nchangepoints_i <- mods$nchangepoints[i]
    data_i <- prep_TS_data(document_covariate_table, LDA_models, mods, i)
    TSmods[[i]] <- TS(data_i, formula_i, nchangepoints_i, weights, control)
  }
  package_TS_on_LDA(TSmods, LDA_models, mods)

}

#' @title Prepare the model-specific data to be used in the TS analysis
#' 
#' @description Append the estimated topic proportions (\eqn{\gamma}) values 
#'   from a fitted LDA model to the document covariate table to create the
#'   data structure needed for \code{TS}.
#'
#' @param document_covariate_table Document covariate table (rows:
#'   documents (\code{M}), columns: time index and covariate options). 
#'   Every model needs a covariate to describe the time value for each
#'   document (in whatever relevant units), whose name in the table is input
#'   via \code{timename}, that dictates the application of the changepoints. 
#'   In addition, the table needs to include as columns all covariates named 
#'   within the specific models described via the argument \code{formula} 
#'   (if desired). Must be a conformable to a data table. 
#'
#' @param LDA_models List of LDA models (class \code{LDA_set}) or a singular
#'   LDA model (class \code{LDA}).
#'
#' @param mods The \code{data.table} created by \code{expand_TS} the contains
#'   each of the models (defined by the LDA model to use and the formula and
#'   number of changepoints for the TS model). Indexded here by \code{i}.
#'
#' @param i \code{integer} index referencing the row in \code{mods} to use.
#'
#' @return Class \code{data.frame} object including [1] the time variable
#'   (indicated in \code{control}), [2] the predictor variables (required by
#'   \code{formula}) and [3], the multinomial response variable (indicated
#'   in \code{formula}), ready for input into \code{TS}.
#'
#' @export
#'
prep_TS_data <- function(document_covariate_table, LDA_models, mods, i){
  if(is(LDA_models, "LDA")){
    LDA_models <- c(LDA_models)
    class(LDA_models) <- c("LDA_set", "list")
  }
  data_i <- document_covariate_table
  data_i$gamma <- LDA_models[[mods$LDA[i]]]@gamma
  data_i
}

#' @title Select the best Time Series model
#'
#' @description Select the best model of interest from an
#'   \code{TS_on_LDA} object, based on a set of user-provided functions. The
#'   functions default to choosing the model with the lowest AIC value.
#'
#' @param TS_models An object of class \code{TS_on_LDA} produced by
#'   \code{TS_on_LDA}.
#'
#' @param control Class \code{LDA_controls} list including (named) elements
#'   corresponding to the \code{measurer} and \code{evaluator} functions.
#'
#' @return A reduced version of \code{TS_models} that only includes the 
#'   selected TS model. The returned object is still an object of
#'   class \code{TS_fit}.
#'
#' @export
#'
select_TS <- function(TS_models, control = TS_controls_list()){
  measurer <- control$measurer
  selector <- control$selector
  TS_measured <- sapply(TS_models, measurer) %>%
                  matrix(ncol = 1)
  TS_selected <- apply(TS_measured, 2, selector) 
  which_selected <- which(TS_measured %in% TS_selected)
  out <- TS_models[[which_selected]]
  class(out)  <- c("TS_fit", "list") 
  out
}

#' @title Determine the AIC (deviance) value of a TS model
#'
#' @description Convenience function to extract the AIC (deviance) element of 
#'   \code{TS_fit}-class object.
#'
#' @param object Class \code{TS_fit} object to be evaluated.
#'
#' @param ... Not used, simply included to maintain method compatability.
#'
#' @param k Not used, simply included to maintain method compatability.
#'
#' @export
#'
AIC.TS_fit <- function(object, ..., k = 2){
  object$deviance
}


#' @title Package the output of TS_on_LDA
#'
#' @description Set the class and name the elements of the results list 
#'   returned from applying \code{\link{TS}} to the combination of TS models
#'   requested for the LDA model(s) input.
#'
#' @param TSmods list of results from \code{\link{TS}} applied for each model 
#'   on each LDA model input.
#'
#' @param LDA_models List of LDA models (class \code{LDA_set}) or a singular
#'   LDA model (class \code{LDA}).
#'
#' @param models \code{data.frame} object returned from 
#'   \code{\link{expand_TS}} that contains the combinations of LDA models, 
#'   and formulas and nchangepoints used in the TS models.
#'
#' @return Class \code{TS_on_LDA} list of results from \code{\link{TS}} 
#'   applied for each model on each LDA model input.
#'
#' @export
#'
package_TS_on_LDA <- function(TSmods, LDA_models, models){
  if(is(LDA_models, "LDA")){
    LDA_models <- c(LDA_models)
    class(LDA_models) <- c("LDA_set", "list")
  }
  nmodels <- nrow(models)
  nms <- rep(NA, nmodels)
  for (i in 1:nmodels){
    nms[i] <- paste0(names(LDA_models)[models$LDA[i]], ", ", 
                     deparse(models$formula[[i]]), ", ", 
                     models$nchangepoints[i], " changepoints")
  }
  names(TSmods) <- nms
  class(TSmods) <- list("TS_on_LDA", "list")
  TSmods
}

#' @title Print a set of Time Series models fit to LDAs
#'
#' @description Convenience function to print only the names of a 
#'   \code{TS_on_LDA}-class object.
#'
#' @param x Class \code{TS_on_LDA} object to be printed.
#'
#' @param ... Not used, simply included to maintain method compatability.
#'
#' @return Nothing (names are printed, not returned).
#'
#' @export
#'
print.TS_on_LDA <- function(x, ...){
  print(names(x))
}

#' @title Print the message to the console about which combination of TS
#'   and LDA is being run
#'
#' @description If desired, print a message at the beginning of every model
#'   combination stating the TS model and the LDA model being evaluated.
#'
#' @param models \code{data.frame} object returned from 
#'   \code{\link{expand_TS}} that contains the combinations of LDA models, 
#'   and formulas and nchangepoints used in the TS models.
#'
#' @param i \code{integer} index of the row to use from \code{models}.
#'
#' @param LDA_models List of LDA models (class \code{LDA_set}) or a singular
#'   LDA model (class \code{LDA}).
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}. Of particular importance here is 
#'   the \code{logical}-class element named \code{quiet}.
#'
#' @return Nothing (message is printed, not returned).
#'
#' @export
#'
print_model_run_message <- function(models, i, LDA_models, control){
  if (control$quiet){
    return(NULL)
  }
  equation <- deparse(models$formula[[i]])
  chngpt_msg <- paste0("with ", models$nchangepoints[i], " changepoints ")
  reg_msg <- paste0("and equation ", equation)
  ts_msg <- paste0(chngpt_msg, reg_msg)
  lda_msg <- names(LDA_models)[models$LDA[i]]
  msg<- paste0("Running TS model ", ts_msg, " on LDA model ", lda_msg, "\n")
  cat(msg)
}

#' @title Expand the TS models needed across the factorial combination of
#'   LDA models, continuous formulas, and number of change points
#' 
#' @description Expand the completely crossed combination of model inputs: 
#'   LDA model results, continuous formulas
#'   
#' @param LDA_models \code{LDA_set}-class object of LDA models.
#' 
#' @param formulas Vector of the continuous formulas. 
#'
#' @param nchangepoints Vector of the number of changepoints.
#'
#' @return Expanded table of the three values: [1] the LDA model (indicated
#'   as a numeric element reference to the \code{LDA_set} object), [2] the 
#'   continuous formula, and [3] the number of changepoints.
#' 
#' @export
#'
expand_TS <- function(LDA_models, formulas, nchangepoints){
  if(is(LDA_models, "LDA")){
    LDA_models <- c(LDA_models)
    class(LDA_models) <- c("LDA_set", "list")
  }
  if(!is(formulas, "vector")){
    if(is(formulas, "formula")){
      formulas <- c(formulas)
    }
  }
  out <- formulas
  for (i in 1:length(formulas)){
    tformula <- paste(as.character(formulas[[i]]), collapse = "")
    out[[i]] <- as.formula(paste("gamma", tformula))
  }
  formulas <- out
  nmods <- length(LDA_models)
  mods <- 1:nmods
  out <- expand.grid(mods, formulas, nchangepoints, stringsAsFactors = FALSE)
  colnames(out) <- c("LDA", "formula", "nchangepoints") 
  out
}

#' @title Verify that nchangepoints vector is proper
#' 
#' @description Verify that the vector of numbers of changepoints is 
#'   conformable to integers greater than 1.
#'   
#' @param nchangepoints Vector of the number of changepoints to evaluate.
#'
#' @return Nothing.
#' 
#' @export
#'
check_nchangepoints <- function(nchangepoints){
  if (!is.numeric(nchangepoints) || any(nchangepoints %% 1 != 0)){
    stop("nchangepoints must be integer-valued")
  }
}

#' @title Verify that weights vector is proper
#' 
#' @description Verify that the vector of document weights is numeric
#'   and inform the user if weights are outside the optimal range: 
#'   \eqn{(0,1]}.
#'   
#' @param weights Vector of the document weights to evaluate.
#'
#' @return Nothing.
#' 
#' @export
#'
check_weights <- function(weights){
  if(!is.null(weights)){
    if (!is.numeric(weights)){
      stop("weights vector must be numeric")
    }
    if (min(weights) <= 0 | max(weights) > 1){
      ideal <- "weights should be scaled to (0,1]; "
      wrange <- paste0("min: ", min(weights), ", max: ", max(weights), "; ")
      warn <- "fit may be unstable"
      warning(paste0(ideal, wrange, warn))
    }
  }
}

#' @title Verify that LDA model input is proper
#' 
#' @description Verify that the \code{LDA_models} input is, in fact, LDA 
#'   models or a singular LDA model. 
#'   
#' @param LDA_models List of LDA models or singular LDA model to evaluate.
#'
#' @return Nothing.
#' 
#' @export
#'
check_LDA_models <- function(LDA_models){
  if(("LDA_set" %in% class(LDA_models)) == FALSE){
    if(is(LDA_models, "LDA") == FALSE){
      stop("LDA_models is not an LDA object or LDA_set object")
    }
  }
}

#' @title Verify that the document covariate table is proper
#' 
#' @description Verify that the table of document-level covariates is 
#'   conformable to a data frame and of the right size (correct number of 
#'   documents) for the document-topic output from the LDA models.
#'   
#' @param document_covariate_table Document covariate table to evaluate.
#'
#' @param LDA_models Reference LDA model list (class \code{LDA_set}) that 
#'   includes as its first element a properly fitted \code{LDA} model with 
#'   a \code{gamma} slot with the document-topic distribution. 
#'
#' @return Nothing.
#' 
#' @export
#'
check_document_covariate_table <- function(document_covariate_table, 
                                           LDA_models){
  dct_df <- tryCatch(data.frame(document_covariate_table),
                     warning = function(x){NA}, error = function(x){NA})
  if (length(dct_df) == 1 && is.na(dct_df)){
    stop("document_covariate_table is not conformable to a data frame")
  }
  if (nrow(document_covariate_table) != nrow(LDA_models[[1]]@gamma)){
    stop("number of documents in covariate table is not equal to number of 
      documents observed")
  }
}

#' @title Verify that the time vector is proper
#' 
#' @description Verify that the vector of time values is included in the 
#'   document covariate table and that it is either numeric or a date.
#'   
#' @param document_covariate_table Document covariate table used to query
#'   for the time column.
#'
#' @param timename Column name for the time variable to evaluate.
#'
#' @return Nothing.
#' 
#' @export
#'
check_timename <- function(document_covariate_table, timename){
  covariate_names <- colnames(document_covariate_table)
  if ((timename %in% covariate_names) == FALSE){
    stop("timename not present in document covariate table")
  }
  time_covariate <- document_covariate_table[ , timename]
  if (!(is.numeric(time_covariate)) & !(is.Date(time_covariate))){
    stop("covariate indicated by timename is not numeric or temporal")
  }
}

#' @title Verify that formulas vector is proper and append the response 
#'   variable
#' 
#' @description Verify that the vector of formulas is actually formatted
#'   as a vector formula objects and that the predictor variables are all 
#'   included in the document covariate table. 
#'   
#' @param formulas Vector of the formulas to evaluate.
#'
#' @param document_covariate_table Document covariate table used to evaluate
#'   the availability of the data required by the formula inputs.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model.
#'
#' @return Nothing.
#' 
#' @export
#'
check_formulas <- function(formulas, document_covariate_table, control){
  response <- control$response
  dct <- document_covariate_table
  if(!is(formulas, "vector")){
    if(is(formulas, "formula")){
      formulas <- c(formulas)
    } else{
      stop("formulas does not contain a formula")
    }
  } else{ 
    if (!all(unlist(lapply(formulas, is, "formula")))){
      stop("formulas is not a vector of formulas")
    }
  }
  resp <- unlist(lapply(lapply(formulas, terms), attr, "response"))
  pred <- unlist(lapply(lapply(formulas, terms), attr, "term.labels"))
  if (any(resp != 0)){
    stop("formula inputs should not include response variable")
  }
  if (!all(pred %in% colnames(dct))){
    misses <- pred[which(pred %in% colnames(dct) == FALSE)]
    mis <- paste(misses, collapse = ", ")
    stop(paste0("formulas include predictors not present in data: ", mis))
  }

}

#' @title Check all of the inputs to TS_on_LDA
#'
#' @description Verify the inputs to (\code{\link{TS_on_LDA}}).
#'
#' @param call Class \code{class} list, holding all of the arguments passed
#'   to \code{\link{TS_on_LDA}}.
#'
#' @return Nothing.
#'
#' @export
#'
check_TS_on_LDA <- function(call){
  call <- as.list(call)
  LDA_models <- eval(call$LDA_models)
  document_covariate_table <- eval(call$document_covariate_table)
  control <- eval(call$control)
  nchangepoints <- eval(call$nchangepoints)
  weights <- eval(call$weights)
  formulas <- eval(call$formulas)
  check_LDA_models(LDA_models)
  check_document_covariate_table(document_covariate_table, LDA_models)
  check_timename(document_covariate_table, control$timename)
  check_formulas(formulas, document_covariate_table, control)  
  check_nchangepoints(nchangepoints)
  check_weights(weights)
}