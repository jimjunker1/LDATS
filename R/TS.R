#' @title Conduct a single Time Series analyses on a set of LDA models
#'
#' @description This is the main interface function for the Time Series 
#'   analyses.
#'
#' @param data Class \code{data.frame} object including [1] the time variable
#'   (indicated in \code{control}), [2] the predictor variables (required by
#'   \code{formula}) and [3], the multinomial response variable (indicated
#'   in \code{formula}). Note that the response variables should be formatted
#'   as \code{<name>.1}, \code{<name>.2}, etc. (where \code{<name>} is the
#'   actual name of the response variable, such as \code{gamma} for a standard
#'   TS analysis of LDA output. 
#'
#' @param formula \code{formula} describing the continuous change. Any 
#'   predictor variable included must also be a column in the
#'   \code{data}.  Any (multinomial) response variable must also be a set of
#'   columns in \code{data}. 
#'
#' @param nchangepoints Integer corresponding to the number of 
#'   change points to include in the model. 0 is a valid input (corresponding
#'   to no change points, so a singular time series model), and the current 
#'   implementation can reasonably include up to 6 change points. The 
#'   number of change points is used to dictate the segementation of the data  
#'   for each continuous model and each LDA model.
#'
#' @param weights Optional class \code{numeric} vector of weights for each 
#'   document. Corresponds to the vector \strong{\eqn{v}} in the math 
#'   description.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}.
#'
#' @return Set of results from TS.
#'
#' @export
#'
TS <- function(data, formula, nchangepoints, weights, 
               control = TS_controls_list()){

  check_timename(data, control$timename)
  check_formula(data, formula)
  TS_memo <- memoise_fun(multinom_TS, control$memoise)
  temps <- prep_temp_sequence(control)
  saves <- prep_saves(nchangepoints, control)
  pdist <- prep_proposal_dist(nchangepoints, control)
  cpts <- initialize_cpts(data, formula, nchangepoints, weights, control)
  pbar <- initialize_pbar(control)

  for(i in 1:control$nit){
    tick_pbar(pbar, control)
  }
}

#' @title Initialize and tick through the progress bar
#'
#' @description \code{initialize_pbar} creates and \code{tick_pbar} steps
#'   through the progress bar (if desired) in \code{\link{TS}}
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}. Of use here is \code{quiet} which is a
#'   a \code{logical} indicator of whether there should be information 
#'   (i.e. the progress bar) printed during the run or not. Default is 
#'   \code{TRUE}.
#'
#' @return \code{initialize_pbar}: the initialized progress bar object.
#'
#' @export
#'
initialize_pbar <- function(control = TS_controls_list()){
  if (control$quiet){
    return()
  }
  form <- "  [:bar] :percent eta: :eta"
  progress_bar$new(form, control$nit, clear = FALSE, width = 60)
}

#' @rdname initialize_pbar
#'
#' @param pbar The progress bar object returned from \code{initialize_pbar}.
#'
#' @return \code{tick_pbar}: the ticked-forward \code{pbar}.
#'
#' @export
#'
tick_pbar <- function(pbar, control = TS_controls_list()){
  if (control$quiet){
    return()
  }
  pbar$tick()
}

#' @title Pre-claculate the proposal distribution for the ptMCMC algorithm
#'
#' @description Calculate the proposal distribution in advance of actually
#'   running the ptMCMC algorithm in order to decrease computation time.
#'   The proposal distribution is a joint of three distributions:
#'   [1] a multinomial distribution selecting among the change points within
#'   the chain, [2] a binomial distribution selecting the direction of the 
#'   step of the change point (earlier or later in the time series), and 
#'   [3] a geometric distribution selecting the magnitude of the step.
#'
#' @param nchangepoints Integer corresponding to the number of 
#'   change points to include in the model. 0 is a valid input (corresponding
#'   to no change points, so a singular time series model), and the current 
#'   implementation can reasonably include up to 6 change points. The 
#'   number of change points is used to dictate the segementation of the data  
#'   for each continuous model and each LDA model.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}. Currently relevant here is 
#'   \code{magnitude} (referenced as \eqn{\kappa} in the math description),
#'   which controls the magnitude of the step size (is the average of the
#'   geometric distribution). 
#'
#' @return List of two matrices: [1] the size of the proposed step for each
#'   iteration of each chain, [2] the identity of the change point location 
#'   to be shifted by the step for each iteration of each chain.
#'
#' @export
#'
prep_proposal_dist <- function(nchangepoints, control = TS_controls_list()){

  ntemps <- control$ntemps
  nit <- control$nit
  if(nchangepoints == 0){
    steps <- matrix(0, nrow = nit, ncol = ntemps)
    which_steps <- matrix(numeric(0), nrow = nit, ncol = ntemps)
  } else{
    magnitude <- control$magnitude 
    step_signs <- sample(c(-1, 1), nit * ntemps, replace = TRUE)
    step_magnitudes <- 1 + rgeom(nit * ntemps, 1 / magnitude)
    steps <- matrix(step_signs * step_magnitudes, nrow = nit)
    which_steps <- sample.int(nchangepoints, nit * ntemps, replace = TRUE)
    which_steps <- matrix(which_steps, nrow = nit)
  }
  list(steps = steps, which_steps = which_steps)
}

#' @title Prepare the data structures to save the ptMCMC output
#'
#' @description Create the data structure used to save the output from 
#'   each iteration of the ptMCMC algorithm.
#'
#' @param nchangepoints Integer corresponding to the number of 
#'   change points to include in the model. 0 is a valid input (corresponding
#'   to no change points, so a singular time series model), and the current 
#'   implementation can reasonably include up to 6 change points. The 
#'   number of change points is used to dictate the segementation of the data  
#'   for each continuous model and each LDA model.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}.
#'
#' @return Vector of temperatures.
#'
#' @export
#'
prep_saves <- function(nchangepoints, control = TS_controls_list()){

  ntemps <- control$ntemps
  nit <- control$nit
  cpts <- array(NA, c(nchangepoints, ntemps, nit))
  lls <- matrix(NA, ntemps, nit)
  ids <- matrix(NA, ntemps, nit)
  accepts <- matrix(NA, ntemps, nit)
  swap_accepts <- matrix(FALSE, nit, ntemps - 1)
  list(cpts = cpts, lls = lls, ids = ids, accepts = accepts, 
       swap_accepts = swap_accepts)
}


#' @title Initialize the changepoint matrix used in the ptMCMC algorithm
#' 
#' @description Each of the chains is initialized using a draw from the 
#'   available times (i.e. assuming a uniform prior), the best fit (by 
#'   likelihood) draw is put in the focal chain with each subsequently worse
#'   fit placed into the subsequently hotter chain. 
#'
#' @param data Class \code{data.frame} object including [1] the time variable
#'   (indicated in \code{control}), [2] the predictor variables (required by
#'   \code{formula}) and [3], the multinomial response variable (indicated
#'   in \code{formula}). Note that the response variables should be formatted
#'   as \code{<name>.1}, \code{<name>.2}, etc. (where \code{<name>} is the
#'   actual name of the response variable, such as \code{gamma} for a standard
#'   TS analysis of LDA output. 
#'
#' @param formula \code{formula} describing the continuous change. Any 
#'   predictor variable included must also be a column in the
#'   \code{data}.  Any (multinomial) response variable must also be a set of
#'   columns in \code{data}. 
#'
#' @param nchangepoints Integer corresponding to the number of 
#'   change points to include in the model. 0 is a valid input (corresponding
#'   to no change points, so a singular time series model), and the current 
#'   implementation can reasonably include up to 6 change points. The 
#'   number of change points is used to dictate the segementation of the data  
#'   for each continuous model and each LDA model.
#'
#' @param weights Optional class \code{numeric} vector of weights for each 
#'   document. Corresponds to the vector \strong{\eqn{v}} in the math 
#'   description.
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}.
#'
#' @return List of [1] matrix of change points (rows) for each temperature 
#'   (columns) and [2] vector of log-likelihood values for each of the chains.
#'
#' @export
#'
initialize_cpts <- function(data, formula, nchangepoints, weights, 
                            control = TS_controls_list()){

  temps <- prep_temp_sequence(control)
  ntemps <- length(temps)
  min_time <- min(data[ , control$timename])
  max_time <- max(data[ , control$timename])
  times <- seq(min_time, max_time, 1)
  avail_times <- times[-c(1, length(times))]
  cps <- matrix(NA, nrow = nchangepoints, ncol = ntemps)
  for (i in 1:ntemps){
    cp_times <- sort(sample(avail_times, nchangepoints, replace = FALSE))
    cps[ , i] <- cp_times
  }
  lls <- rep(NA, ntemps)
  for (i in 1:ntemps){
    lls[i] <- multinom_TS(data, formula, cps[ , i], weights, control)$logLik
  }  
  cps <- cps[ , order(lls, decreasing = TRUE), drop = FALSE]
  lls <- sort(lls, decreasing = TRUE)

  out <- list(cps, lls)
  names(out) <- c("changepts", "lls")
  out
}



#' @title Prepare the ptMCMC temperature sequence
#'
#' @description Create the series of temperatures used in the ptMCMC algorithm
#'
#' @param control Class \code{TS_controls} list, holding control parameters
#'   for the Time Series model including the parallel tempering Markov Chain 
#'   Monte Carlo (ptMCMC) controls, generated by 
#'   \code{\link{TS_controls_list}}.
#'
#' @return Vector of temperatures.
#'
#' @export
#'
prep_temp_sequence <- function(control = TS_controls_list()){

  ntemps <- control$ntemps
  penultimate_temp <- control$penultimate_temp
  ultimate_temp <- control$ultimate_temp
  q <- control$q
  sequence <- seq(0, log2(penultimate_temp), length.out = ntemps - 1)
  log_temps <- sequence^(1 + q) / log2(penultimate_temp)^q
  c(2^(log_temps), ultimate_temp) 
}


#' @title Verify that a formula is proper
#' 
#' @description Verify that the formula is actually a formula and that the
#'   response and predictor variabless are all included in the data.
#'   
#' @param formula Formula to evaluate.
#'
#' @param data Class \code{data.frame} object including [1] the time variable
#'   (indicated in \code{control}), [2] the predictor variables (required by
#'   \code{formula}) and [3], the multinomial response variable (indicated
#'   in \code{control}).
#'
#' @return Nothing.
#' 
#' @export
#'
check_formula <- function(data, formula){

  if (!is(formula, "formula")){
    stop("formula does not contain a single formula")
  }

  respLoc <- attr(terms(formula), "response")
  if (respLoc == 0){
    stop("formula inputs should include response variable")
  }  

  resp <- as.character(attr(terms(formula), "variables"))[-1][respLoc]
  pred <- attr(terms(formula), "term.labels")
  if (!resp %in% colnames(data)){
    stop("formula includes response not present in data")
  }
  if (!all(pred %in% colnames(data))){
    misses <- pred[which(pred %in% colnames(data) == FALSE)]
    mis <- paste(misses, collapse = ", ")
    stop(paste0("formula includes predictors not present in data: ", mis))
  }
}


#' @title Create the controls list for the Time Series model
#'
#' @description This function provides a simple creation and definition of a
#'   list used to control the time series model fit occurring within 
#'   \code{\link{TS}}. 
#'
#' @param memoise \code{logical} indicator of whether the multinomial 
#'   functions should be memoised (via \code{\link[memoise]{memoise}}). 
#'   Memoisation happens to both \code{\link{multinom_TS}} and 
#'   \code{\link{multinom_TS_chunk}}.
#'
#' @param response \code{character} element indicating the response variable 
#'   used in the time series. 
#'
#' @param timename \code{character} element indicating the time variable
#'   used in the time series. 
#'
#' @param ntemps \code{integer} number of temperatures to use in the 
#'   ptMCMC (referenced as \eqn{H} in the math description).
#'
#' @param penultimate_temp Penultimate temperature in the ptMCMC sequence.
#'
#' @param ultimate_temp Ultimate temperature in the ptMCMC sequence.
#'
#' @param q Exponent controlling the ptMCMC temperature sequence from the 
#'   focal chain (reference with temperature = 1) to the penultimate chain. 0
#'   (default) implies a geometric sequence. 1 implies squaring before 
#'   exponentiating.
#'
#' @param nit \code{integer} number of iterations (steps) used in the ptMCMC
#'   algorithm (referenced as \eqn{G} in the math description).
#'
#' @param magnitude Average magnitude (defining a geometric distribution)
#'   for the proposed step size in the ptMCMC algorithm (referenced as 
#'   \eqn{\kappa} in the math description).
#'
#' @param quiet \code{logical} indicator of whether the model should run 
#'   quietly (if \code{FALSE}, a progress bar is returned).
#'
#' @return List of class \code{TS_controls}.
#'
#' @export
#'
TS_controls_list <- function(memoise = TRUE, response = "gamma", 
                             timename = "newmoon", ntemps = 6, 
                             penultimate_temp = 2^6, ultimate_temp = 1e10,
                             q = 0, nit = 1e4, magnitude = 12, 
                             quiet = FALSE){
  out <- list(memoise = memoise, response = response, timename = timename,
              ntemps = ntemps, penultimate_temp = penultimate_temp,
              ultimate_temp = ultimate_temp, q = q, nit = nit,
              magnitude = magnitude, quiet = quiet)
  class(out) <- c("TS_controls", "list")
  out
}

#' @title Logical control on whether or not to memoise
#'
#' @description This function provides a simple, logical toggle control on
#'   whether the function \code{fun} should be memoised via
#'   \code{\link[memoise]{memoise}} or not. 
#'
#' @param fun Function name to (potentially) be memoised.
#'
#' @param memoise_fun \code{logical} value indicatiing if \code{fun} should be 
#'   memoised.
#'
#' @return \code{fun}, memoised if desired.
#'
#' @export
#'
memoise_fun <- function(fun, memoise_fun){
  if (memoise_fun){
    fun <- memoise(fun)
  }
  fun
}